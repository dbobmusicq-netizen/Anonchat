<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Anonymous P2P Mesh Chat</title>
    <!-- 
        MIT License
        Copyright (c) 2023 Anonymous P2P Chat

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
    -->

    <style>
        /* --- CSS RESET & VARIABLES --- */
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent: #00bcd4;
            --accent-hover: #00acc1;
            --msg-me: #005662;
            --msg-peer: #2c2c2c;
            --sys-msg: #ff9800;
            --border: #333;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-family);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- HEADER & STATUS --- */
        header {
            background-color: var(--container-bg);
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
            flex-shrink: 0;
        }

        .room-info h1 { font-size: 1.1rem; font-weight: 600; }
        .room-info span { font-size: 0.8rem; color: var(--text-muted); }
        .status-badge {
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 12px;
            background: #333;
            color: #fff;
        }
        .status-badge.online { background: #2e7d32; }
        .status-badge.offline { background: #c62828; }

        /* --- CHAT AREA --- */
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 80%;
        }

        .message-wrapper.me { align-self: flex-end; align-items: flex-end; }
        .message-wrapper.peer { align-self: flex-start; align-items: flex-start; }
        .message-wrapper.system { align-self: center; max-width: 95%; align-items: center; }

        .message-bubble {
            padding: 10px 14px;
            border-radius: 18px;
            font-size: 0.95rem;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .me .message-bubble { background-color: var(--msg-me); border-bottom-right-radius: 4px; }
        .peer .message-bubble { background-color: var(--msg-peer); border-bottom-left-radius: 4px; }
        
        .sender-name {
            font-size: 0.7rem;
            margin-bottom: 2px;
            color: var(--text-muted);
            margin-left: 8px;
        }
        .me .sender-name { display: none; } /* Hide my own name */

        .system-msg {
            background-color: transparent;
            color: var(--text-muted);
            font-size: 0.8rem;
            text-align: center;
            font-style: italic;
            border: 1px solid var(--border);
            padding: 4px 12px;
            border-radius: 20px;
        }

        .timestamp {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
            margin-top: 4px;
            text-align: right;
        }

        /* --- INPUT AREA --- */
        #input-area {
            background-color: var(--container-bg);
            padding: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        #message-input {
            flex: 1;
            background: #2b2b2b;
            border: 1px solid #333;
            color: white;
            padding: 12px;
            border-radius: 24px;
            font-size: 1rem;
        }

        #message-input:focus { border-color: var(--accent); }

        #send-btn {
            background-color: var(--accent);
            color: #000;
            border: none;
            padding: 0 20px;
            border-radius: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        #send-btn:hover { background-color: var(--accent-hover); }
        #send-btn:disabled { background-color: #444; color: #888; cursor: not-allowed; }

        /* --- TYPING INDICATOR --- */
        #typing-indicator {
            position: absolute;
            bottom: 70px;
            left: 20px;
            font-size: 0.75rem;
            color: var(--accent);
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            display: none;
            pointer-events: none;
        }

        /* --- MOBILE TWEAKS --- */
        @media (max-width: 600px) {
            .message-wrapper { max-width: 90%; }
        }
    </style>
</head>
<body>

    <header>
        <div class="room-info">
            <h1>Mesh Chat <span style="color:var(--accent);">v1.0</span></h1>
            <span id="connection-count">Connecting...</span>
        </div>
        <div id="status-badge" class="status-badge offline">Offline</div>
    </header>

    <div id="chat-container">
        <!-- Messages inject here -->
        <div class="message-wrapper system">
            <div class="system-msg">Welcome to the anonymous mesh. You are <b id="my-username-display">...</b></div>
        </div>
    </div>

    <div id="typing-indicator">Someone is typing...</div>

    <form id="input-area" onsubmit="sendMessage(event)">
        <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" disabled>
        <button type="button" id="send-btn" onclick="sendMessage(event)" disabled>Send</button>
    </form>

<script>
    /**
     * CONFIGURATION & CONSTANTS
     */
    // Generate a semi-permanent topic ID based on the URL or hardcoded string.
    // Important: In a real app, make this unique to avoid public collisions.
    const ROOM_ID = 'github-p2p-mesh-v2-global'; 
    
    // Using ntfy.sh as a free, public, CORS-friendly signaling channel.
    // No backend code required. It uses GET (SSE) for receiving and POST for sending.
    const SIGNALING_URL = `https://ntfy.sh/${ROOM_ID}`; 
    
    // Mesh limits to prevent browser crash
    const MAX_PEERS = 15; 
    
    const ICE_SERVERS = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    /**
     * STATE MANAGEMENT
     */
    const myId = crypto.randomUUID();
    const myUsername = 'Anon-' + Math.floor(Math.random() * 10000);
    document.getElementById('my-username-display').textContent = myUsername;

    // Peers object: { [peerId]: { conn: RTCPeerConnection, channel: RTCDataChannel, username: string } }
    const peers = {}; 
    let eventSource = null; // The signaling connection
    
    // Typing state
    let typingTimeout = null;

    /**
     * INITIALIZATION
     */
    async function init() {
        console.log(`[Init] My ID: ${myId}`);
        updateStatus('Connecting Signal...');
        
        // Start Signaling (Subscribe to SSE)
        connectSignaling();

        // Periodically announce presence to discover peers
        setInterval(() => {
            if (Object.keys(peers).length < MAX_PEERS) {
                sendSignal('presence', { username: myUsername });
            }
        }, 5000);

        // Announce immediately
        setTimeout(() => sendSignal('presence', { username: myUsername }), 1000);
        
        // Setup Input listeners
        const input = document.getElementById('message-input');
        input.addEventListener('input', handleTyping);
    }

    /**
     * SIGNALING (NTFY.SH)
     */
    function connectSignaling() {
        // SSE Listener
        eventSource = new EventSource(`${SIGNALING_URL}/sse`);
        
        eventSource.onopen = () => {
            updateStatus('Signal Active', true);
            enableChat();
        };

        eventSource.onerror = () => {
            updateStatus('Signal Error', false);
            disableChat();
        };

        eventSource.onmessage = async (event) => {
            try {
                const data = JSON.parse(event.data);
                // ntfy wraps the payload in 'message', we assume our payload is inside or it IS the body
                // With ntfy, event.data is the JSON info. The actual message content is in data.message
                if (!data.message) return;
                
                const signal = JSON.parse(data.message);
                if (signal.sender === myId) return; // Ignore self
                
                handleSignal(signal);
            } catch (e) {
                // Ignore malformed JSON (heartbeats etc)
            }
        };
    }

    async function sendSignal(type, payload, targetId = null) {
        const body = JSON.stringify({
            type,
            sender: myId,
            target: targetId,
            ...payload
        });

        // Fire and forget fetch to ntfy.sh
        try {
            await fetch(SIGNALING_URL, {
                method: 'POST',
                body: body,
                headers: { 'Title': 'Sig' } // Header required by ntfy sometimes to avoid spam filters
            });
        } catch (e) {
            console.error('Signaling send error', e);
        }
    }

    /**
     * WEBRTC CORE LOGIC
     */
    async function handleSignal(signal) {
        const { type, sender, target, sdp, candidate, username } = signal;

        // If signal is targeted, it must match my ID
        if (target && target !== myId) return;

        // 1. Peer Discovery (Presence)
        if (type === 'presence') {
            // Collision handling: We only initiate if our ID > their ID to avoid glare
            // And only if we aren't already connected
            if (!peers[sender] && myId > sender) {
                if (Object.keys(peers).length >= MAX_PEERS) return; // Mesh full
                initiateConnection(sender, username);
            }
            return;
        }

        // 2. Offer
        if (type === 'offer') {
            if (peers[sender]) return; // Already connecting
            if (Object.keys(peers).length >= MAX_PEERS) return; // Room full
            await acceptConnection(sender, sdp, username);
            return;
        }

        // 3. Answer
        if (type === 'answer' && peers[sender]) {
            await peers[sender].conn.setRemoteDescription(new RTCSessionDescription(sdp));
            return;
        }

        // 4. ICE Candidate
        if (type === 'ice' && peers[sender]) {
            try {
                await peers[sender].conn.addIceCandidate(candidate);
            } catch (e) {
                console.warn('ICE Error', e);
            }
            return;
        }
    }

    // Initiator: Creates Offer
    async function initiateConnection(peerId, peerUsername) {
        console.log(`[WebRTC] Initiating to ${peerId}`);
        const pc = createPeerConnection(peerId, peerUsername);
        
        // Create Data Channel
        const dc = pc.createDataChannel("chat");
        setupDataChannel(dc, peerId);
        
        peers[peerId].channel = dc;

        // Create Offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        sendSignal('offer', { sdp: offer, username: myUsername }, peerId);
    }

    // Receiver: Accepts Offer, Creates Answer
    async function acceptConnection(peerId, remoteSdp, peerUsername) {
        console.log(`[WebRTC] Accepting from ${peerId}`);
        const pc = createPeerConnection(peerId, peerUsername);
        
        pc.ondatachannel = (e) => {
            setupDataChannel(e.channel, peerId);
            peers[peerId].channel = e.channel;
        };

        await pc.setRemoteDescription(new RTCSessionDescription(remoteSdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        sendSignal('answer', { sdp: answer }, peerId);
    }

    function createPeerConnection(peerId, peerUsername) {
        const pc = new RTCPeerConnection(ICE_SERVERS);
        
        // Store peer info
        peers[peerId] = { conn: pc, username: peerUsername || 'Anon' };

        // ICE Handler
        pc.onicecandidate = (e) => {
            if (e.candidate) {
                sendSignal('ice', { candidate: e.candidate }, peerId);
            }
        };

        // Connection State
        pc.onconnectionstatechange = () => {
            if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                removePeer(peerId);
            }
        };

        return pc;
    }

    function removePeer(id) {
        if (peers[id]) {
            appendSystemMessage(`${peers[id].username} left.`);
            peers[id].conn.close();
            delete peers[id];
            updateUserCount();
        }
    }

    /**
     * DATA CHANNEL (MESSAGING)
     */
    function setupDataChannel(dc, peerId) {
        dc.onopen = () => {
            console.log(`[DataChannel] Open with ${peerId}`);
            appendSystemMessage(`${peers[peerId].username} joined.`);
            updateUserCount();
        };

        dc.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (data.type === 'chat') {
                appendMessage(peers[peerId].username, data.content, 'peer');
            } else if (data.type === 'typing') {
                showTypingIndicator(peers[peerId].username);
            }
        };
    }

    // Broadcast to all connected peers
    function broadcastData(data) {
        const json = JSON.stringify(data);
        Object.values(peers).forEach(p => {
            if (p.channel && p.channel.readyState === 'open') {
                p.channel.send(json);
            }
        });
    }

    /**
     * UI LOGIC
     */
    function sendMessage(e) {
        e.preventDefault();
        const input = document.getElementById('message-input');
        const text = input.value.trim();
        
        if (!text) return;

        // Render locally
        appendMessage('Me', text, 'me');

        // Send to peers
        broadcastData({ type: 'chat', content: text });

        input.value = '';
    }

    function appendMessage(sender, text, type) {
        const container = document.getElementById('chat-container');
        
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${type}`;
        
        // Escape HTML
        const safeText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        
        const nameHtml = type === 'peer' ? `<div class="sender-name">${sender}</div>` : '';
        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        wrapper.innerHTML = `
            ${nameHtml}
            <div class="message-bubble">
                ${safeText}
                <div class="timestamp">${time}</div>
            </div>
        `;
        
        container.appendChild(wrapper);
        container.scrollTop = container.scrollHeight;
    }

    function appendSystemMessage(text) {
        const container = document.getElementById('chat-container');
        const el = document.createElement('div');
        el.className = 'message-wrapper system';
        el.innerHTML = `<div class="system-msg">${text}</div>`;
        container.appendChild(el);
        container.scrollTop = container.scrollHeight;
    }

    function updateUserCount() {
        const count = Object.keys(peers).length + 1; // +1 for me
        document.getElementById('connection-count').innerText = `${count} users online`;
    }

    function updateStatus(text, isOnline = false) {
        const badge = document.getElementById('status-badge');
        badge.innerText = text;
        badge.className = `status-badge ${isOnline ? 'online' : 'offline'}`;
    }

    function enableChat() {
        document.getElementById('message-input').disabled = false;
        document.getElementById('send-btn').disabled = false;
    }

    function disableChat() {
        document.getElementById('message-input').disabled = true;
        document.getElementById('send-btn').disabled = true;
    }

    function handleTyping() {
        broadcastData({ type: 'typing' });
    }

    function showTypingIndicator(username) {
        const el = document.getElementById('typing-indicator');
        el.innerText = `${username} is typing...`;
        el.style.display = 'block';
        
        if (typingTimeout) clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            el.style.display = 'none';
        }, 1000);
    }

    // Start App
    window.addEventListener('load', init);

</script>
</body>
  </html>
