
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Mesh Chat v8.0 - Master</title>
    <!-- 
        MIT License | Anonymous P2P Mesh Chat v8.0
        Combined Features: Reliable Peering, Private Chat, 10MB Files, Mobile UI
    -->
    <style>
        :root {
            /* DARK MODE (Default) */
            --bg: #0f172a; --panel: #1e293b; --text: #f1f5f9; --muted: #94a3b8;
            --accent: #3b82f6; --accent-dim: #2563eb;
            --me-bg: #0f4c81; --peer-bg: #334155;
            --sys-bg: #1e293b; --private: #8b5cf6;
            --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, sans-serif;
        }

        body.light-mode {
            --bg: #f8fafc; --panel: #ffffff; --text: #0f172a; --muted: #64748b;
            --accent: #0ea5e9; --me-bg: #0ea5e9; --peer-bg: #e2e8f0; --sys-bg: #f1f5f9;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }

        body {
            background: var(--bg); color: var(--text); font-family: var(--font);
            height: 100vh; height: 100dvh; /* Mobile viewport fix */
            display: flex; flex-direction: column; overflow: hidden;
        }

        /* HEADER */
        header {
            background: var(--panel); height: 60px; padding: 0 15px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid rgba(128,128,128,0.2); flex-shrink: 0; z-index: 10;
            transition: background 0.3s;
        }
        
        /* PRIVATE MODE STYLING */
        body.private-active header { background: #2e1065; border-bottom: 1px solid var(--private); }
        body.private-active .brand span { color: #c4b5fd; }
        body.private-active #send-btn { background: var(--private); }
        body.private-active .me .bubble { background: #5b21b6; }

        .brand { font-weight: 800; font-size: 1.1rem; display: flex; align-items: center; gap: 8px; }
        .brand span { color: var(--accent); }
        
        /* Status Dot */
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #ef4444; box-shadow: 0 0 5px #ef4444; transition: 0.3s; }
        .status-dot.green { background: #22c55e; box-shadow: 0 0 5px #22c55e; }
        .status-dot.orange { background: #f59e0b; box-shadow: 0 0 5px #f59e0b; }

        .header-controls { display: flex; gap: 12px; align-items: center; }
        .icon-btn { width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.05); display: grid; place-items: center; cursor: pointer; border: none; color: var(--text); }
        .icon-btn:hover { background: rgba(255,255,255,0.1); }

        /* CHAT AREA */
        #chat-view { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; scroll-behavior: smooth; }
        
        .msg { display: flex; flex-direction: column; max-width: 85%; animation: fade 0.2s; }
        @keyframes fade { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .msg.me { align-self: flex-end; align-items: flex-end; }
        .msg.peer { align-self: flex-start; align-items: flex-start; }
        .msg.sys { align-self: center; max-width: 95%; align-items: center; margin: 10px 0; }

        .bubble { padding: 10px 14px; border-radius: 18px; font-size: 0.95rem; line-height: 1.4; word-wrap: break-word; }
        .me .bubble { background: var(--me-bg); color: #fff; border-bottom-right-radius: 4px; }
        .peer .bubble { background: var(--peer-bg); color: var(--text); border-bottom-left-radius: 4px; }
        
        .sender { font-size: 0.7rem; color: var(--muted); margin-bottom: 2px; margin-left: 10px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .sender:hover { color: var(--accent); text-decoration: underline; }
        .me .sender { display: none; }

        .sys-bubble { background: var(--sys-bg); color: var(--muted); padding: 4px 12px; border-radius: 20px; font-size: 0.75rem; text-align: center; border: 1px solid rgba(128,128,128,0.1); }

        /* PRIVATE HEADER BAR */
        #private-header { display: none; align-items: center; gap: 10px; color: #fff; font-size: 0.9rem; width: 100%; }
        body.private-active #private-header { display: flex; }
        body.private-active #global-header { display: none; }

        /* INPUT AREA */
        #input-zone { background: var(--panel); padding: 10px; display: flex; gap: 10px; align-items: center; border-top: 1px solid rgba(128,128,128,0.2); padding-bottom: calc(10px + env(safe-area-inset-bottom)); }
        #msg-input { flex: 1; background: rgba(0,0,0,0.2); border: 1px solid rgba(128,128,128,0.2); padding: 12px 16px; border-radius: 24px; color: var(--text); font-size: 1rem; }
        #msg-input:focus { border-color: var(--accent); }
        #send-btn { background: var(--accent); border: none; width: 44px; height: 44px; border-radius: 50%; color: #fff; cursor: pointer; font-weight: bold; flex-shrink: 0; }
        #send-btn:disabled { background: var(--muted); opacity: 0.5; }

        /* FILE ATTACHMENT */
        .chat-img { max-width: 100%; border-radius: 10px; margin-top: 5px; cursor: pointer; }
        .file-attach { display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px; margin-top: 5px; }
        .progress-bar { width: 100%; height: 4px; background: #333; border-radius: 2px; margin-top: 5px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s; }

        /* UTILS */
        .hidden { display: none; }
    </style>
</head>
<body>

<header>
    <!-- GLOBAL HEADER -->
    <div class="brand" id="global-header">
        <div id="conn-dot" class="status-dot"></div>
        <div>Mesh<span>Chat</span></div>
    </div>

    <!-- PRIVATE CHAT HEADER -->
    <div id="private-header">
        <button class="icon-btn" onclick="exitPrivate()" style="width:auto; padding:0 10px; border-radius:4px; font-size:0.8rem">← Back</button>
        <span id="pvt-username">User</span>
    </div>

    <div class="header-controls">
        <span id="peer-count" style="font-size:0.75rem; color:var(--muted)">0 Peers</span>
        <button class="icon-btn" onclick="forceReconnect()" title="Reset Connection">↻</button>
        <button class="icon-btn" onclick="document.body.classList.toggle('light-mode')" title="Theme">◑</button>
    </div>
</header>

<div id="chat-view">
    <div class="msg sys"><div class="sys-bubble">Initializing Mesh Network...</div></div>
</div>

<form id="input-zone" onsubmit="sendMessage(event)">
    <label style="cursor:pointer; color:var(--muted); padding:5px">
        <input type="file" class="hidden" onchange="sendFile(this)">
        <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/></svg>
    </label>
    <input type="text" id="msg-input" placeholder="Type a message..." autocomplete="off">
    <button type="button" id="send-btn" onclick="sendMessage(event)">➤</button>
</form>

<script>
/**
 * --- V8.0 CONFIGURATION ---
 * Global Room: 'mesh-v8-global' ensures everyone sees each other.
 * Signaling: Free ntfy.sh (No server setup required).
 * STUN: Massive list to punch through mobile networks.
 */
const ROOM_ID = 'mesh-chat-v8-master'; 
const SIGNAL_URL = 'https://ntfy.sh/';
const CHUNK_SIZE = 16 * 1024; // 16KB chunks for WebRTC stability

const ICE_CONFIG = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' }
    ]
};

// Application State
const state = {
    myId: 'U-' + Math.floor(Math.random() * 1000000), // Random ID
    myName: 'Anon-' + Math.floor(Math.random() * 1000),
    peers: {}, // { peerId: { conn, dc, username, connected } }
    msgs: { global: [] }, // Stores chat history: 'global' or peerId
    activeChat: 'global', // 'global' or peerId
    downloads: {}, // Tracks incoming files
    seenSignals: new Set() // Deduplication
};

/* --- INITIALIZATION --- */
function init() {
    logSystem(`Welcome <b>${state.myName}</b>. Waiting for peers...`);
    
    // Connect to Signaling SSE
    const es = new EventSource(`${SIGNAL_URL}${ROOM_ID}/sse`);
    es.onopen = () => {
        updateDot('orange');
        // Aggressive Discovery: Announce every 4 seconds
        setInterval(() => broadcastSignal('presence', { name: state.myName }), 4000);
        broadcastSignal('presence', { name: state.myName });
    };
    es.onerror = () => updateDot('red');
    es.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data.message) handleSignal(JSON.parse(data.message));
        } catch(err) {}
    };
}

// Send signal to ntfy.sh
function broadcastSignal(type, data, targetId = null) {
    const id = Math.random().toString(36);
    const body = JSON.stringify({ type, sender: state.myId, target: targetId, id, ...data });
    fetch(`${SIGNAL_URL}${ROOM_ID}`, { method: 'POST', body, headers: { 'Title': 'Sig' } }).catch(()=>{});
}

/* --- WEBRTC ENGINE (Polite Peer) --- */
async function handleSignal(sig) {
    if (sig.sender === state.myId || state.seenSignals.has(sig.id)) return;
    if (sig.target && sig.target !== state.myId) return;
    state.seenSignals.add(sig.id);

    const peerId = sig.sender;
    
    // 1. PRESENCE & COLLISION HANDLING
    if (sig.type === 'presence') {
        // If we aren't connected, and My ID > Their ID, I initiate.
        // This ensures only ONE person calls, preventing "Glare".
        if (!state.peers[peerId] && state.myId > peerId) {
            initiatePeer(peerId, sig.name, true);
        }
        return;
    }

    // 2. CREATE PEER IF MISSING (Passive)
    if (!state.peers[peerId]) initiatePeer(peerId, sig.name || 'Anon', false);

    const pc = state.peers[peerId].conn;

    // 3. HANDLE SIGNALS
    try {
        if (sig.type === 'offer') {
            await pc.setRemoteDescription(sig.sdp);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            broadcastSignal('answer', { sdp: answer }, peerId);
        } else if (sig.type === 'answer') {
            await pc.setRemoteDescription(sig.sdp);
        } else if (sig.type === 'ice') {
            await pc.addIceCandidate(sig.candidate);
        }
    } catch (e) { console.error(e); }
}

function initiatePeer(peerId, username, initiator) {
    if (state.peers[peerId]) return;

    const pc = new RTCPeerConnection(ICE_CONFIG);
    state.peers[peerId] = { conn: pc, username: username, connected: false };

    pc.onicecandidate = e => { if (e.candidate) broadcastSignal('ice', { candidate: e.candidate }, peerId); };
    
    pc.onconnectionstatechange = () => {
        const s = pc.connectionState;
        if (s === 'connected') {
            state.peers[peerId].connected = true;
            updateDot('green');
            logSystem(`${state.peers[peerId].username} joined.`);
            updateCount();
        } else if (s === 'failed' || s === 'disconnected') {
            closePeer(peerId);
        }
    };

    if (initiator) {
        const dc = pc.createDataChannel("chat");
        setupDC(dc, peerId);
        pc.createOffer().then(o => { pc.setLocalDescription(o); broadcastSignal('offer', { sdp: o, name: state.myName }, peerId); });
    } else {
        pc.ondatachannel = e => setupDC(e.channel, peerId);
    }
}

function setupDC(dc, peerId) {
    state.peers[peerId].dc = dc;
    dc.onopen = () => {
        // Send current name on connect
        dc.send(JSON.stringify({ type: 'name', name: state.myName }));
    };
    dc.onmessage = e => handleData(peerId, JSON.parse(e.data));
}

function closePeer(peerId) {
    if (state.peers[peerId]) {
        state.peers[peerId].conn.close();
        logSystem(`${state.peers[peerId].username} left.`);
        delete state.peers[peerId];
        if (state.activeChat === peerId) exitPrivate();
        updateCount();
        if (Object.keys(state.peers).length === 0) updateDot('orange');
    }
}

/* --- DATA & ROUTING --- */
function handleData(peerId, data) {
    const peer = state.peers[peerId];
    
    // Name Update
    if (data.type === 'name') { peer.username = data.name; return; }

    // Chat Routing
    // If msg is private, chatId = peerId. If global, chatId = 'global'.
    const chatId = data.isPrivate ? peerId : 'global';
    
    // Notification for Private Msg while in Global
    if (data.isPrivate && state.activeChat !== peerId) {
        logSystem(`Private message from <b>${peer.username}</b>. <u onclick="startPrivate('${peerId}')" style="cursor:pointer;color:var(--accent)">Reply</u>`);
    }

    if (data.type === 'chat') {
        storeMsg(chatId, { sender: peer.username, text: data.text, type: 'peer', peerId: peerId });
    } else if (data.type === 'file_start') {
        // Init download
        state.downloads[data.id] = { chunks: [], total: data.total, count: 0, meta: data, chatId: chatId };
        storeMsg(chatId, { sender: peer.username, isFile: true, meta: data, type: 'peer', peerId: peerId });
    } else if (data.type === 'file_chunk') {
        const dl = state.downloads[data.id];
        if (dl) {
            dl.chunks[data.idx] = data.chunk;
            dl.count++;
            // Update Progress Bar
            if (state.activeChat === chatId) {
                const el = document.getElementById(`prog-${data.id}`);
                if (el) el.style.width = ((dl.count / dl.total) * 100) + '%';
            }
            // Finish
            if (dl.count === dl.total) finishFile(data.id);
        }
    }

    if (state.activeChat === chatId) renderChat();
}

function finishFile(id) {
    const dl = state.downloads[id];
    const blob = dl.chunks.join('');
    // Replace progress bar with download link/image
    const el = document.getElementById(`file-box-${id}`);
    if (el) {
        if (dl.meta.type.startsWith('image/')) {
            el.innerHTML = `<img src="${blob}" class="chat-img" onclick="window.open(this.src)">`;
        } else {
            el.innerHTML = `<a href="${blob}" download="${dl.meta.name}" style="color:var(--accent)">Download ${dl.meta.name}</a>`;
        }
    }
}

/* --- MESSAGING & UI --- */
function sendMessage(e) {
    e.preventDefault();
    const inp = document.getElementById('msg-input');
    const text = inp.value.trim();
    if (!text) return;

    storeMsg(state.activeChat, { sender: 'Me', text: text, type: 'me' });
    renderChat();

    const isPrivate = state.activeChat !== 'global';
    const payload = JSON.stringify({ type: 'chat', text: text, isPrivate });

    if (isPrivate) {
        const p = state.peers[state.activeChat];
        if (p && p.dc) p.dc.send(payload);
    } else {
        Object.values(state.peers).forEach(p => p.dc.send(payload));
    }
    inp.value = '';
}

function sendFile(inp) {
    const f = inp.files[0];
    if (!f) return;
    if (f.size > 10 * 1024 * 1024) { alert('Max 10MB'); return; }

    const reader = new FileReader();
    reader.onload = e => {
        const raw = e.target.result;
        const id = Math.random().toString(36).substr(2, 9);
        const total = Math.ceil(raw.length / CHUNK_SIZE);
        const isPrivate = state.activeChat !== 'global';
        const meta = { id, name: f.name, type: f.type, total, isPrivate };

        // Local UI
        storeMsg(state.activeChat, { sender: 'Me', isFile: true, meta: meta, type: 'me', completed: true, data: raw });
        renderChat();

        // Broadcast Start
        const targets = isPrivate ? [state.peers[state.activeChat]] : Object.values(state.peers);
        targets.forEach(p => p.dc.send(JSON.stringify({ type: 'file_start', ...meta })));

        // Send Chunks
        let idx = 0;
        const sendLoop = () => {
            if (idx >= total) return;
            const chunk = raw.slice(idx * CHUNK_SIZE, (idx + 1) * CHUNK_SIZE);
            targets.forEach(p => p.dc.send(JSON.stringify({ type: 'file_chunk', id, idx, chunk })));
            idx++;
            setTimeout(sendLoop, 10); // Throttle
        };
        sendLoop();
    };
    reader.readAsDataURL(f);
    inp.value = '';
}

/* --- PRIVATE CHAT SYSTEM --- */
window.startPrivate = (peerId) => {
    state.activeChat = peerId;
    document.body.classList.add('private-active');
    document.getElementById('pvt-username').innerText = state.peers[peerId].username;
    renderChat();
};

window.exitPrivate = () => {
    state.activeChat = 'global';
    document.body.classList.remove('private-active');
    renderChat();
};

/* --- UI HELPERS --- */
function storeMsg(chatId, msg) {
    if (!state.msgs[chatId]) state.msgs[chatId] = [];
    state.msgs[chatId].push(msg);
}

function renderChat() {
    const view = document.getElementById('chat-view');
    view.innerHTML = '';
    const list = state.msgs[state.activeChat] || [];
    
    list.forEach(msg => {
        const div = document.createElement('div');
        div.className = `msg ${msg.type}`;

        // Header (Sender Name)
        let header = '';
        if (msg.type === 'peer') {
            header = `<div class="sender" onclick="startPrivate('${msg.peerId}')" title="Click to Private Chat">
                ${msg.sender} ${state.activeChat === 'global' ? '<span style="font-size:0.6rem; opacity:0.7">➜ PM</span>' : ''}
            </div>`;
        }

        if (msg.type === 'sys') {
            div.innerHTML = `<div class="sys-bubble">${msg.text}</div>`;
        } else if (msg.isFile) {
            // File Rendering
            if (msg.type === 'me') {
                // Sent by me (show preview immediately)
                const content = msg.meta.type.startsWith('image/') 
                    ? `<img src="${msg.data}" class="chat-img">`
                    : `<div style="padding:10px; color:#fff">Sent: ${msg.meta.name}</div>`;
                div.innerHTML = `<div class="bubble">${content}</div>`;
            } else {
                // Received (Show Progress or Result)
                div.innerHTML = `${header}<div class="bubble" id="file-box-${msg.meta.id}">
                    <div>Receiving: ${msg.meta.name}</div>
                    <div class="progress-bar"><div class="progress-fill" id="prog-${msg.meta.id}"></div></div>
                </div>`;
            }
        } else {
            // Text Message
            div.innerHTML = `${header}<div class="bubble">${msg.text.replace(/</g,"&lt;")}</div>`;
        }
        view.appendChild(div);
    });
    view.scrollTop = view.scrollHeight;
}

function logSystem(text) {
    storeMsg(state.activeChat, { text, type: 'sys' });
    renderChat();
}

function forceReconnect() {
    logSystem("Resetting connections...");
    Object.keys(state.peers).forEach(k => { try { state.peers[k].conn.close(); } catch(e){} delete state.peers[k]; });
    updateCount();
    updateDot('orange');
    broadcastSignal('presence', { name: state.myName });
}

function updateDot(color) { document.getElementById('conn-dot').className = `status-dot ${color}`; }
function updateCount() { document.getElementById('peer-count').innerText = `${Object.keys(state.peers).length} Peers`; }

window.onload = init;
</script>
</body>
    </html>
